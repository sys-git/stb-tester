#!/usr/bin/env python

import stbt

with stbt.ArgvHider():
    import pygst  # gstreamer
    pygst.require("0.10")
    import gst

import argparse
import itertools
import sys

def parseArgs(args=sys.argv[1:]):
    parser = OptionParser(version=1, description='Create a single Stb-Tester test script')
    defaults = loadDefaultArgs('record')
    #    Common options:
    parser.add_option('--source-pipeline',
                      action="store",
                      dest="source_pipeline",
                      type="str",
                      help='A gstreamer pipeline to use for A/V input (default: %(default)s).')
    parser.add_option('--sink-pipeline',
                      action="store",
                      dest="sink_pipeline",
                      type="str",
                      help='A gstreamer pipeline to use for video output (default: %(default)s).')
    parser.add_option('--debug-level',
                      action="store",
                      dest="debug_level",
                      type="int",
                      help='The debug level to use.')
    parser.add_option("--control",
                      action="store",
                      dest="control",
                      default=None,
                      help='The remote control to control the stb (default: %(default)s).')
    #    Record specific options:
    parser.add_option("--output-file",
                      action="store",
                      dest="output_file",
                      help='The output script file to write.')
    parser.add_option("--control-recorder",
                      action="store",
                      dest="control_recorder",
                      help='The control to use for the recordings.')
    parser.add_option("--cleanup-on-failure",
                      action="store_true",
                      dest="cleanup_on_failure",
                      default=False,
                      help='Cleanup output directory if recording fails.')
    parser.set_defaults(**defaults)
    try:
        options, args = parser.parse_args(args=args)
    except Exception, _e:
        traceback.print_exc()
    return options, args

class TestRecorder(object):
    def __init__(self, args, script):
        self._args = args
        self._script = script
        self._outputDirname = os.path.dirname(args.output_file)
        self._debugger = Debugger(args.debug_level)
        self._display = RecorderDisplay(args.source_pipeline, args.sink_pipeline, self._debugger)
        self._setup()
    def debugger(self):
        return self._debugger
    def _setup(self):
        self._clearOutputDir()
        mkdir(self._outputDirname)
        try:
            self._fp = open(self._args.output_file, 'w')
        except IOError as e:
            e.strerror = "Failed to write to output-file '%s': %s"%(os.path.realpath(self._args.output_file), e.strerror)
            raise
        open(os.path.join(self._outputDirname, "__init__.py"), "w").write("'''\nAuto-generated test.\n'''")
    def teardown(self, failure=None):
        if failure and (self._args.cleanup_on_failure!=None):
            self._clearOutputDir()
    def _clearOutputDir(self):
        try:    shutil.rmtree(self._outputDirname)
        except: pass
    def record(self):
        try:
            self._record(
                         self._display,
                         RemoteRecorderFactory(self._args.control_recorder, self._debugger),
                         RemotePlaybackFactory(self._args.control, self._display, self._debugger),
                         self._fp,
                         self._outputDirname,
                         self._debugger,
                         )
        finally:
            try:    self._fp.close()
            except: pass
            self._debugger.debug("Script recording finished.")
    @staticmethod
    def _record(display, remoteInput, control, scriptOut, outputDirname, debugger):
        count = itertools.count()
        oldKey = None
        while True:
            interrupt = False
            try:
                key = remoteInput.next()
            except (KeyboardInterrupt, StopIteration):
                interrupt = True
            buf = display.getScreenshot().get_property('last-buffer')
            if not interrupt:
                control.press(key)
            if oldKey:
                filename = '%04d-%s-complete.png' % (count.next(), oldKey)
                saveFrame(buf, os.path.join(outputDirname, filename))
                scriptOut.write("wait_for_match('%s')\n" % filename)
            if interrupt:
                return
            scriptOut.write("press('%s')\n" % key)
            oldKey = key

if __name__ == '__main__':
    (args, script) = parseArgs()
    recorder = TestRecorder(args, script)
    debugger = recorder.debugger()
    try:
        recorder.record()
        failure = None
    except Exception, failure:
        debugger.error("FAIL: Recording incomplete!")
        sys.exit(1)
    finally:
        recorder.teardown(failure)
